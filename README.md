# 동시성 제어 방식 분석 및 보고서

## 1. 동시성 문제란?
동시성 문제는 여러 스레드(또는 프로세스)가 동시에 같은 데이터에 접근하거나 변경할 때 발생하는 데이터 불일치, 레이스 컨디션, 데드락 등의 문제를 의미합니다. 특히 포인트 충전/사용과 같이 상태가 변경되는 연산에서는 동시성 문제가 발생할 수 있습니다.

## 2. 동시성 제어 방식의 종류 및 선택 이유

### (1) Synchronized/Lock (JVM 기반)
- 자바/Kotlin에서 가장 기본적인 동시성 제어 방식입니다.
- `synchronized` 키워드 또는 `ReentrantLock` 등 Lock 객체를 사용하여 임계영역을 보호합니다.
- 단일 인스턴스 환경에서 효과적이며, 메모리 내에서만 동작합니다.

### (2) DB 트랜잭션/락
- 데이터베이스의 트랜잭션 격리 수준, 행/테이블 락 등을 활용합니다.
- 여러 인스턴스(분산 환경)에서도 일관성을 보장할 수 있습니다.
- 성능 저하, 데드락 등 부작용이 있을 수 있습니다.
- **본 프로젝트에서는 DB 락을 사용하지 않고, DB에 의존하지 않는 동시성 제어가 요구되어 제외하였습니다.**

### (3) 분산 락 (Distributed Lock)
- 여러 서버/프로세스에서 동시에 접근하는 환경에서 사용합니다.
- Redis, ZooKeeper, etcd 등 외부 시스템을 활용하여 락을 관리합니다.
- 대표적으로 Redisson(분산 Redis 락), ZooKeeper 기반 Curator 등이 있습니다.
- **본 프로젝트는 단일 서버 환경이므로 분산 락은 오버스펙이라 제외하였습니다.**

### (4) AOP 기반 락
- 메서드 단위로 어노테이션을 붙여 락을 적용할 수 있습니다.
- 코드와 락 로직이 분리되어 유지보수가 용이합니다.
- 내부적으로는 위의 Lock/분산락 중 하나를 사용합니다.
- **본 프로젝트는 AOP 관련 의존성이 추가되어 있지 않고, 의도적으로 해당 방식을 사용하지 않으므로 제외하였습니다.**

#### **선택한 방식**
- **JVM 메모리 기반 Lock(ConcurrentHashMap + ReentrantLock) 방식**을 사용하였습니다.
- 단일 인스턴스 환경에서 효율적이고, 외부 시스템이나 DB에 의존하지 않으면서도 충분한 동시성 안전성을 제공합니다.

## 3. 각 방식의 장단점

| 방식                | 장점                                   | 단점                                  |
|---------------------|----------------------------------------|---------------------------------------|
| Synchronized/Lock   | 구현이 간단, JVM 내에서 빠름           | 분산 환경에서는 효과 없음             |
| DB 트랜잭션/락      | 분산 환경에서 일관성 보장               | 성능 저하, 데드락 위험                |
| 분산 락             | 분산 환경에서 동시성 제어 가능           | 외부 시스템 의존, 구현 복잡           |
| AOP 기반            | 코드와 락 분리, 선언적 적용 가능         | 내부 구현에 따라 한계 존재            |

---

## 4. 본 프로젝트에서 사용한 동시성 제어 방식 및 효과

### 사용한 방식:  
**userId별로 메모리 기반 Lock(ReentrantLock)을 관리하는 UserLockManager 컴포넌트**를 서비스에 주입하여,  
동일 userId에 대한 요청이 동시에 들어와도 순차적으로 처리되도록 구현하였습니다.

#### UserLockManager의 구현 방식
- 내부적으로 `ConcurrentHashMap<Long, ReentrantLock>`을 사용하여 userId별로 락을 관리합니다.
- 서비스 레이어에서 UserLockManager의 `withUserLock(userId) { ... }` 메서드를 통해 임계영역을 지정합니다.
- 락은 JVM 메모리 내에서만 동작하며, 단일 인스턴스 환경에서만 유효합니다.

#### 왜 이 방식을 선택했는가?
- **DB에 대한 의존성이 없으므로 DB 트랜잭션/락을 사용할수없어 선택하지 않았습니다**
- **분산 락은 단일 인스턴스 환경에서는 오버스펙이므로 선택하지 않았습니다.**
- **AOP 방식은 최초에 고려했으나 기존 프로젝트의 의존성에 포함되어 있지 않아 해당 구현을 의도한게 아니라고 생각해 선택하지않았습니다.**

#### UserLockManager의 장점
- 동일 userId에 대한 요청이 동시에 들어와도 **순차적으로 처리되어 포인트 데이터의 일관성을 보장합니다.**
- JVM 메모리 내에서만 동작하므로 성능이 빠르고, 외부 시스템에 의존하지 않습니다
- **비즈니스 로직과 락 관리 책임을 분리하여 유지보수성을 높였습니다.**
- **테스트에서는 NoOpUserLockManager를 사용하여 락의 영향 없이 비즈니스 로직만 검증할 수 있습니다.**
- **단일 인스턴스 환경**에서 매우 효과적이며, 코드가 단순하고 빠릅니다.

---
